#!/usr/bin/env perl
# vi: fdm=marker

# Use directives {{{1
################################################################

use strict;
use warnings "all";
use Deep::Hash::Utils;
use File::Basename;
use File::Spec::Functions;
use File::Temp;
use Getopt::Long;
use Git::Repository;
use JSON;
use LWP::Simple;
use XML::Simple;
use YAML::Tiny;

# Constants {{{1
################################################################

my $SCRIPTNAME = basename($0);
my $SCRIPTPATH = dirname($0);

# Variables {{{1
################################################################

my $CHECK_ALL = 0;
my $CHECK_CONTAINERS = 0;
my $CHECK_TOOLS = 0;
my $CHECK_WORKFLOWS = 0;
my %CONTAINERS;
my $HELP = 0;
my $INPUT_FOLDER = '.';
my %TOOLS;
my %WORKFLOWS;

# Print help {{{1
################################################################

sub print_help {
	print "Usage: $SCRIPTNAME [options]

This program will scan the configuration files for tools, and check
that they are correctly defined.

Options:
   -a, --check-all        Check all.
   -c, --check-containers Check containers.
   -h, --help             Print this help message and exits.
   -i,--input <FOLDER>    Set the input folder to use. Default is '.'.
   -t, --check-tools      Check tools.
   -w, --check-workflows  Check workflows.
";
	exit(0);
}

# Read args {{{1
################################################################

sub read_args {

	GetOptions(
		'check-all|a' => \$CHECK_ALL,
		'check-containers|c' => \$CHECK_CONTAINERS,
		'help|h' => \$HELP,
		'input|i' => \$INPUT_FOLDER,
		'check-tools|t' => \$CHECK_TOOLS,
		'check-workflows|w' => \$CHECK_WORKFLOWS
	) or print_help();

	# Help
	print_help() if $HELP;

	# Check left arguments.
	if (@ARGV > 0) {
		print "No arguments allowed.\n";
		print_help();
	}

	# Check all
	$CHECK_CONTAINERS = $CHECK_TOOLS = $CHECK_WORKFLOWS = 1 if $CHECK_ALL;
}

# Check message {{{1
################################################################

sub check_msg($$$$) {

	my ($msg_type, $type, $id, $msg) = @_;

	# Check message type
	die "Unknown message type $msg_type." unless grep(lc($msg_type), qw(error warning));

	# Print message
	print(uc("[$msg_type on $type")." $id] $msg\n");
}

# Get tool XML file full path {{{1
################################################################

sub get_tool_xml_file_full_path($) {

	my ($xml_file) = @_;

	my $xml_file_path = File::Spec::Functions::catfile($INPUT_FOLDER, 'tools', $xml_file);

	return $xml_file_path;
}

# Get tool XML files {{{1
################################################################

sub get_tool_xml_files {

	my $tool_conf_file = File::Spec::Functions::catfile($INPUT_FOLDER, 'config', 'tool_conf.xml');
	die "No file \"$tool_conf_file\"." unless -f $tool_conf_file;

	# Read tool_conf.xml and get all XML tool paths.
	my @tool_xml_files;
	my $xml_parser = new XML::Simple;
	my $tools = $xml_parser->XMLin($tool_conf_file);
	while (my @keys = Deep::Hash::Utils::reach($tools)) {
		push(@tool_xml_files, $keys[-1]) if ($keys[-2] eq 'file');
	}

	# Filter out non-PhenoMeNal tools
	@tool_xml_files = grep(/^phenomenal\//, @tool_xml_files);

	# Filter out all non existing files
	my @only_existing_files;
	for my $xml_file (@tool_xml_files) {
		my $xml_file_full_path = get_tool_xml_file_full_path($xml_file);
		if ( -f $xml_file_full_path) {
			push(@only_existing_files, $xml_file);
		}
		else {
			check_msg("ERROR", "TOOL", "unknown", "Cannot find tool XML file \"$xml_file_full_path\", while reading \"$tool_conf_file\".");
		}
	}
	@tool_xml_files = @only_existing_files;

	return @tool_xml_files;
}

# Read tool XML files {{{1
################################################################

sub read_tool_xml_files() {

	my @tool_xml_files = get_tool_xml_files();

	my $xml_parser = new XML::Simple();
	for my $xml_file (@tool_xml_files) {
		my $xml_file_path = File::Spec::Functions::catfile($INPUT_FOLDER, 'tools', $xml_file);
		my $tool = $xml_parser->XMLin($xml_file_path);

		# Version
		die "No tool ID defined inside XML tool file $xml_file_path." if ( ! exists($$tool{id}));
		my $tool_id = $$tool{id};
		$TOOLS{$tool_id} = { id => $tool_id };

		# Name
		$TOOLS{$tool_id}->{name} = $$tool{name} if exists($$tool{name});
			
		# Version
		$TOOLS{$tool_id}->{version} = $$tool{version} if exists($$tool{version});

		# Command
		if (exists($$tool{command})) {
			if (ref($$tool{command})) {
				$TOOLS{$tool_id}->{command}->{interpreter} = $$tool{command}->{interpreter} if exists($$tool{command}->{interpreter});
				$TOOLS{$tool_id}->{command}->{content} = $$tool{command}->{content} if exists($$tool{command}->{content});
			}
			else {
				$TOOLS{$tool_id}->{command}->{content} = $$tool{command};
			}
		}
	}
}

# Read PhenoMeNal tools2container YAML {{{1
################################################################

sub read_phenomenal_tools2container_yaml() {

	my $yaml_file = File::Spec::Functions::catfile($INPUT_FOLDER, 'config', 'phenomenal_tools2container.yaml');
	die "No file \"$yaml_file\"." unless -f $yaml_file;

	# Load YAML file
	my $phn_tools2cont = YAML::Tiny->read($yaml_file)->[0];
	die "Unable to find assignment key in $yaml_file." unless exists($$phn_tools2cont{assignment});
	for my $container (@{$$phn_tools2cont{assignment}}) {

		# Check that required field are defined
		for my $field (qw(docker_image_override docker_tag_override tools_id)) {
			die "No $field field in container." unless exists($$container{$field});
		}

		my $name = $$container{docker_image_override};
		my $tag = $$container{docker_tag_override};
		$CONTAINERS{$name} = { name => $name, tag => $tag };

		# Loop on all tools of the container
		for my $tool_id (@{$$container{tools_id}}) {
			check_msg("ERROR", "TOOL", $tool_id, "Unknown tool found in container $name, file $yaml_file.") unless exists($TOOLS{$tool_id});
			$TOOLS{$tool_id}->{container} = $CONTAINERS{$name};
		}
	}
}

# Read job conf XML {{{1
################################################################

sub read_job_conf() {

	my $xml_file = File::Spec::Functions::catfile($INPUT_FOLDER, 'config', 'job_conf.xml');
	die "No file \"$xml_file\"." unless -f $xml_file;

	# Load XML file
	my $xml_parser = new XML::Simple();
	my $job_conf = $xml_parser->XMLin($xml_file);
	while (my ($tool_id, $job) = each %{$job_conf->{tools}->{tool}}) {
		$TOOLS{$tool_id}->{job_destination} = $job->{destination} if exists $TOOLS{$tool_id} && exists($job->{destination});
	}
}

# Read tools info {{{1
################################################################

sub read_tools_info() {

	if (keys(%TOOLS) == 0) {
		# Read first info from tool XML files
		read_tool_xml_files();
	}
}

# Read containers info {{{1
################################################################

sub read_containers_info() {

	if (keys(%CONTAINERS) == 0) {

		read_tools_info();

		# Read phenomenal_tools2container.yaml
		read_phenomenal_tools2container_yaml();

		# Read job_conf.xml
		read_job_conf();
	}
}

# Check command {{{1
################################################################

sub check_command(\%) {

	my ($tool) = @_;

	check_msg("WARNING", "TOOL", $tool->{id}, "Command uses an interpreter attribute. Use of interpreter attribute inside command tag is discouraged. It tends to make embedded code more complex and renders difficult testing. Please get rid of your explicit call to \"$$tool{command}->{interpreter}\" interpreter, and write a script using a shebang that you will call directly from inside the command tag content, using command line arguments to get different behavious. Testing if such a script is a lot easier, since it can be done outside of Galaxy scope.") if exists $$tool{command}->{interpreter};
	check_msg("ERROR", "TOOL", $tool->{id}, "Command uses \$__tool_directory__ variable. Please remove it, as it will prevent the tool to launch in PhenoMeNal Galaxy.") if grep(/\$__tool_directory__/, $$tool{command}->{content});
	check_msg("WARNING", "TOOL", $tool->{id}, "Command uses a complex command (use of && or ; operators). Please simply by calling only one script or program that you can test more accurately outside of Galaxy environment.") if grep(/(&&|;)/, $$tool{command}->{content});
}

# Check container {{{1
################################################################

sub check_container(\%) {

	my ($tool) = @_;

	# Check container tag format
	if ($tool->{container}->{tag} eq 'latest') {
		check_msg("ERROR", "TOOL", $tool->{id}, "Container tag is set to latest.");
	}
	elsif ($tool->{container}->{tag} =~ m/^(dev_)?v.+_cv.+$/) {

		# Extract tool version
		(my $tool_version = $tool->{container}->{tag}) =~ s/^(dev_)?v(.+)_cv.+$/$2/;
		check_msg("ERROR", "TOOL", $tool->{id}, "Version ($tool_version) contained inside container tag $tool->{container}->{tag} does not match the version ($tool->{version}) defined inside the tool XML file.") unless $tool_version eq $tool->{version};
	}
	else {
		check_msg("ERROR", "TOOL", $tool->{id}, "Container tag $tool->{container}->{tag} does not match the format '^(dev_)?v.+_cv.+\$'.");
	}
}

# Check job destination {{{1
################################################################

sub check_job_destination(\%) {

	my ($tool) = @_;

	check_msg("ERROR", "TOOL", $tool->{id}, "No job destination defined.") if not exists($tool->{job_destination});
	check_msg("WARNING", "TOOL", $tool->{id}, "Job destination ($tool->{job_destination}) is not generic.") if $tool->{job_destination} !~ m/^dynamic-k8s-.*$/;
}

# Check container repos {{{1
################################################################

sub check_container_repos(\%) {

	my ($tool) = @_;

	# Try to clone repos
	my $repos_name = "container-$tool->{container}->{name}";
	my $repos_url = "https://github.com/phnmnl/$repos_name";
	if (head($repos_url)) {
# TODO Get containers repos and check tool version in README
		# TODO optmize by not testing multiple times the same container. => Keep an hash about containers. Then just test version number for tools.
		my $dir = File::Temp::tempdir();
		Git::Repository->run(clone => $repos_url, $dir);
		my $r = Git::Repository->new(work_tree => $dir );
	}
	else {
		check_msg("ERROR", "TOOL", $tool->{id}, "Cannot find container GitHub repository $repos_name at $repos_url.");
	}
}

# Read workflows info {{{1
################################################################

sub read_workflows_info() {

	if (keys(%WORKFLOWS) == 0) {

		# List .ga files in workflows folder
		my @ga_files = <workflows/*.ga>;

		# Load all .ga files
		for my $ga_file (@ga_files) {
			my $workflow;
			{
				local $/;
				open my $fh, '<', $ga_file or die "can't open $ga_file: $!";
				my $json = <$fh>;
				$workflow = JSON::decode_json($json);
			}

			# Check that required field are defined
			for my $field (qw(uuid name steps)) {
				die "No $field field in workflow file \"$ga_file\"." unless exists($workflow->{$field});
			}

			# List tools
			my @tools;
			while (my ($step_n, $step) = each %{$workflow->{steps}}) {
				if (exists($step->{tool_id}) && defined $step->{tool_id}) {
					my %tool = (id => $step->{tool_id});
					if (exists($step->{tool_version}) && defined $step->{tool_version}) {
						$tool{version} = $step->{tool_version};
					}
					else {
						check_msg('ERROR', 'WORKFLOW', $workflow->{name}, "No tool version defined for tool $step->{tool_id} at step $step_n of workflow.");
					}
					push(@tools, \%tool);
				}
				else {
					check_msg('ERROR', 'WORKFLOW', $workflow->{name}, "No tool ID defined for step $step_n of workflow.");
				}
			}

			# Set new workflow
			$WORKFLOWS{$workflow->{uuid}} = { id => $workflow->{uuid}, name => $workflow->{name}, tools => \@tools};
		}
	}
}

# Check workflows {{{1
################################################################

sub check_workflows() {

	# Load files
	read_tools_info();
	read_workflows_info();

	# Loop on all workflows
	foreach my $workflow (values %WORKFLOWS) {

		# Loop on all workflow's tools
		foreach my $tool (@{$workflow->{tools}}) {

			# Check that the tool is known
			check_msg('ERROR', 'WORKFLOW', $workflow->{name}, "Unknown tool $tool->{id}.") unless exists($TOOLS{$tool->{id}});

			# Check tool version
			check_msg('ERROR', 'WORKFLOW', $workflow->{name}, "Version $tool->{version} of tool $tool->{id} requested by workflow, but version $TOOLS{$tool->{id}}->{version} declared in tool_conf.xml.") unless $TOOLS{$tool->{id}}->{version} eq $tool->{version};
		}
	}
}

# Main {{{1
################################################################

# Read arguments
read_args();

# Read tools info
read_tools_info();

# Loop on all tools
foreach my $tool_id (sort keys %TOOLS) {
	my %tool = %{$TOOLS{$tool_id}};
	check_command(%tool) if $CHECK_TOOLS;
	check_container(%tool) if $CHECK_CONTAINERS;
	check_job_destination(%tool) if $CHECK_CONTAINERS;
	check_container_repos(%tool) if $CHECK_CONTAINERS;
}

check_workflows if $CHECK_WORKFLOWS;

# TODO Check that container exists
# TODO Check latest container version on Jenkins.
# TODO Check version of tools in workflows.
# TODO Run it automatically on Travis-CI.
# TODO Pay attention to do not publish names in this file.
# TODO Try to publish report on slack, on some channel (public-admin or release_dalcotidine?).
# TODO Add color option. Use Ncurses?
# TODO Fail (exit > 0) when at least one error is encountered.
