#!/usr/bin/env perl
# vi: fdm=marker

# Use directives {{{1
################################################################

use strict;
use warnings "all";
use Deep::Hash::Utils;
use File::Basename;
use File::Spec::Functions;
use File::Temp;
use Getopt::Long;
use Git::Repository;
use LWP::Simple;
use XML::Simple;
use YAML::Tiny;

# Constants {{{1
################################################################

my $SCRIPTNAME = basename($0);
my $SCRIPTPATH = dirname($0);

# Variables {{{1
################################################################

my $CHECK_ALL = 0;
my $CHECK_CONTAINERS = 0;
my $CHECK_TOOLS = 0;
my $CHECK_WORKFLOWS = 0;
my %CONTAINERS;
my $HELP = 0;
my $INPUT_FOLDER = '.';
my %TOOLS;

# Print help {{{1
################################################################

sub print_help {
	print "Usage: $SCRIPTNAME [options]

This program will scan the configuration files for tools, and check
that they are correctly defined.

Options:
   -a, --check-all        Check all.
   -c, --check-containers Check containers.
   -h, --help             Print this help message and exits.
   -i,--input <FOLDER>    Set the input folder to use. Default is '.'.
   -t, --check-tools      Check tools.
   -w, --check-workflows  Check workflows.
";
	exit(0);
}

# Read args {{{1
################################################################

sub read_args {

	GetOptions(
		'check-all|a' => \$CHECK_ALL,
		'check-containers|c' => \$CHECK_CONTAINERS,
		'help|h' => \$HELP,
		'input|i' => \$INPUT_FOLDER,
		'check-tools|t' => \$CHECK_TOOLS,
		'check-workflows|w' => \$CHECK_WORKFLOWS
	) or print_help();

	# Help
	print_help() if $HELP;

	# Check left arguments.
	if (@ARGV > 0) {
		print "No arguments allowed.\n";
		print_help();
	}

	# Check all
	$CHECK_CONTAINERS = $CHECK_TOOLS = $CHECK_WORKFLOWS = 1 if $CHECK_ALL;
}

# Check message {{{1
################################################################

sub check_msg($$$$) {

	my ($msg_type, $type, $id, $msg) = @_;

	print(uc("[$msg_type on $type")." $id] $msg\n");
}

# Get tool XML files {{{1
################################################################

sub get_tool_xml_files {

	my $tool_conf_file = File::Spec::Functions::catfile($INPUT_FOLDER, 'config', 'tool_conf.xml');
	die "No file \"$tool_conf_file\"." unless -f $tool_conf_file;

	# Read tool_conf.xml and get all XML tool paths.
	my @tool_xml_files;
	my $xml_parser = new XML::Simple;
	my $tools = $xml_parser->XMLin($tool_conf_file);
	while (my @keys = Deep::Hash::Utils::reach($tools)) {
		push(@tool_xml_files, $keys[-1]) if ($keys[-2] eq 'file');
	}

	# Filter out non-PhenoMeNal tools
	@tool_xml_files = grep(/^phenomenal\//, @tool_xml_files);

	return @tool_xml_files;
}

# Read tool XML files {{{1
################################################################

sub read_tool_xml_files() {

	my @tool_xml_files = get_tool_xml_files();

	my $xml_parser = new XML::Simple();
	for my $xml_file (@tool_xml_files) {
		my $xml_file_path = File::Spec::Functions::catfile($INPUT_FOLDER, 'tools', $xml_file);
		my $tool = $xml_parser->XMLin($xml_file_path);

		# Version
		die "No tool ID defined inside XML tool file $xml_file_path." if ( ! exists($$tool{id}));
		my $tool_id = $$tool{id};
		$TOOLS{$tool_id} = { id => $tool_id };

		# Name
		$TOOLS{$tool_id}->{name} = $$tool{name} if exists($$tool{name});
			
		# Version
		$TOOLS{$tool_id}->{version} = $$tool{version} if exists($$tool{version});

		# Command
		if (exists($$tool{command})) {
			if (ref($$tool{command})) {
				$TOOLS{$tool_id}->{command}->{interpreter} = $$tool{command}->{interpreter} if exists($$tool{command}->{interpreter});
				$TOOLS{$tool_id}->{command}->{content} = $$tool{command}->{content} if exists($$tool{command}->{content});
			}
			else {
				$TOOLS{$tool_id}->{command}->{content} = $$tool{command};
			}
		}
	}
}

# Read PhenoMeNal tools2container YAML {{{1
################################################################

sub read_phenomenal_tools2container_yaml() {

	my $yaml_file = File::Spec::Functions::catfile($INPUT_FOLDER, 'config', 'phenomenal_tools2container.yaml');
	die "No file \"$yaml_file\"." unless -f $yaml_file;

	# Load YAML file
	my $phn_tools2cont = YAML::Tiny->read($yaml_file)->[0];
	die "Unable to find assignment key in $yaml_file." unless exists($$phn_tools2cont{assignment});
	for my $container (@{$$phn_tools2cont{assignment}}) {

		# Check that required field are defined
		for my $field (qw(docker_image_override docker_tag_override tools_id)) {
			die "No $field field in container." unless exists($$container{$field});
		}

		my $name = $$container{docker_image_override};
		my $tag = $$container{docker_tag_override};
		$CONTAINERS{$name} = { name => $name, tag => $tag };

		# Loop on all tools of the container
		for my $tool_id (@{$$container{tools_id}}) {
			check_msg("ERROR", "TOOL", $tool_id, "Unknown tool found in container $name, file $yaml_file.") unless exists($TOOLS{$tool_id});
			$TOOLS{$tool_id}->{container} = $CONTAINERS{$name};
		}
	}
}

# Read job conf XML {{{1
################################################################

sub read_job_conf() {

	my $xml_file = File::Spec::Functions::catfile($INPUT_FOLDER, 'config', 'job_conf.xml');
	die "No file \"$xml_file\"." unless -f $xml_file;

	# Load XML file
	my $xml_parser = new XML::Simple();
	my $job_conf = $xml_parser->XMLin($xml_file);
	while (my ($tool_id, $job) = each %{$job_conf->{tools}->{tool}}) {
		$TOOLS{$tool_id}->{job_destination} = $job->{destination} if exists $TOOLS{$tool_id} && exists($job->{destination});
	}
}

# Read tools info {{{1
################################################################

sub read_tools_info {

	# Read first info from tool XML files
	read_tool_xml_files();

	# Read phenomenal_tools2container.yaml
	read_phenomenal_tools2container_yaml();

	# Read job_conf.xml
	read_job_conf();
}

# Check command {{{1
################################################################

sub check_command(\%) {

	my ($tool) = @_;

	check_msg("WARNING", "TOOL", $tool->{id}, "Command uses an interpreter attribute. Use of interpreter attribute inside command tag is discouraged. It tends to make embedded code more complex and renders difficult testing. Please get rid of your explicit call to \"$$tool{command}->{interpreter}\" interpreter, and write a script using a shebang that you will call directly from inside the command tag content, using command line arguments to get different behavious. Testing if such a script is a lot easier, since it can be done outside of Galaxy scope.") if exists $$tool{command}->{interpreter};
	check_msg("ERROR", "TOOL", $tool->{id}, "Command uses \$__tool_directory__ variable. Please remove it, as it will prevent the tool to launch in PhenoMeNal Galaxy.") if grep(/\$__tool_directory__/, $$tool{command}->{content});
	check_msg("WARNING", "TOOL", $tool->{id}, "Command uses a complex command (use of && or ; operators). Please simply by calling only one script or program that you can test more accurately outside of Galaxy environment.") if grep(/(&&|;)/, $$tool{command}->{content});
}

# Check container {{{1
################################################################

sub check_container(\%) {

	my ($tool) = @_;

	# Check container tag format
	if ($tool->{container}->{tag} eq 'latest') {
		check_msg("ERROR", "TOOL", $tool->{id}, "Container tag is set to latest.");
	}
	elsif ($tool->{container}->{tag} =~ m/^(dev_)?v.+_cv.+$/) {

		# Extract tool version
		(my $tool_version = $tool->{container}->{tag}) =~ s/^(dev_)?v(.+)_cv.+$/$2/;
		check_msg("ERROR", "TOOL", $tool->{id}, "Version ($tool_version) contained inside container tag $tool->{container}->{tag} does not match the version ($tool->{version}) defined inside the tool XML file.") unless $tool_version eq $tool->{version};
	}
	else {
		check_msg("ERROR", "TOOL", $tool->{id}, "Container tag $tool->{container}->{tag} does not match the format '^(dev_)?v.+_cv.+\$'.");
	}
}

# Check job destination {{{1
################################################################

sub check_job_destination(\%) {

	my ($tool) = @_;

	check_msg("ERROR", "TOOL", $tool->{id}, "No job destination defined.") if not exists($tool->{job_destination});
	check_msg("WARNING", "TOOL", $tool->{id}, "Job destination ($tool->{job_destination}) is not generic.") if $tool->{job_destination} !~ m/^dynamic-k8s-.*$/;
}

# Check container repos {{{1
################################################################

sub check_container_repos(\%) {

	my ($tool) = @_;

	# Try to clone repos
	my $repos_name = "container-$tool->{container}->{name}";
	my $repos_url = "https://github.com/phnmnl/$repos_name";
	if (head($repos_url)) {
# TODO Get containers repos and check tool version in README
		# TODO optmize by not testing multiple times the same container. => Keep an hash about containers. Then just test version number for tools.
		my $dir = File::Temp::tempdir();
		Git::Repository->run(clone => $repos_url, $dir);
		my $r = Git::Repository->new(work_tree => $dir );
	}
	else {
		check_msg("ERROR", "TOOL", $tool->{id}, "Cannot find container GitHub repository $repos_name at $repos_url.");
	}
}

# Main {{{1
################################################################

# Read arguments
read_args();

# Read tools info
read_tools_info();

# Loop on all tools
foreach my $tool_id (sort keys %TOOLS) {
	my %tool = %{$TOOLS{$tool_id}};
	check_command(%tool) if $CHECK_TOOLS;
	check_container(%tool) if $CHECK_CONTAINERS;
	check_job_destination(%tool) if $CHECK_CONTAINERS;
	check_container_repos(%tool) if $CHECK_CONTAINERS;
}

# TODO Check that container exists
# TODO Check latest container version on Jenkins.
# TODO Check version of tools in workflows.
# TODO Run it automatically on Travis-CI.
# TODO Pay attention to do not publish names in this file.
# TODO Try to publish report on slack, on some channel (public-admin or release_dalcotidine?).
# TODO Add color option.
# TODO Fail (exit > 0) when at least one error is encountered.
