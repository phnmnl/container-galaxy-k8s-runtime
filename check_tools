#!/usr/bin/env perl

use strict;
use warnings "all";
use Deep::Hash::Utils;
use File::Basename;
use File::Spec::Functions 'catfile';
use Getopt::Long;
use XML::Simple;
use YAML::Tiny;

# Constants {{{1
################################################################

my $SCRIPTNAME = basename($0);
my $SCRIPTPATH = dirname($0);

# Variables {{{1
################################################################

my $INPUT_FOLDER = '.';
my $HELP = 0;

# Print help {{{1
################################################################

sub print_help {
	print "Usage: $SCRIPTNAME [options]

This program will scan the configuration files for tools, and check
that they are correctly defined.

Options:
   -h, --help           Print this help message and exits.
   -i,--input <FOLDER>  Set the input folder to use. Default is '.'.
"
}

# Read args {{{1
################################################################

sub read_args {

	GetOptions('help|h' => \$HELP, 'input|i' => \$INPUT_FOLDER) or print_help();

	print_help() if $HELP;

	if (@ARGV > 0) {
		print "No arguments allowed.\n";
		print_help();
	}
}

# Tool error {{{1
################################################################

sub tool_error($) {
	my ($msg) = @_;

	print("[TOOL ERROR] $msg\n");
}

# Tool warning {{{1
################################################################

sub tool_warning($) {
	my ($msg) = @_;

	print("[TOOL WARNING] $msg\n");
}

# Get tool XML files {{{1
################################################################

sub get_tool_xml_files {

	my $tool_conf_file = catfile($INPUT_FOLDER, 'config', 'tool_conf.xml');
	die "No file \"$tool_conf_file\"." unless -f $tool_conf_file;

	# Read tool_conf.xml and get all XML tool paths.
	my @tool_xml_files;
	my $xml_parser = new XML::Simple;
	my $tools = $xml_parser->XMLin($tool_conf_file);
	while (my @keys = Deep::Hash::Utils::reach($tools)) {
		push(@tool_xml_files, $keys[-1]) if ($keys[-2] eq 'file');
	}

	# Filter out non-PhenoMeNal tools
	@tool_xml_files = grep(/^phenomenal\//, @tool_xml_files);

	return @tool_xml_files;
}

# Read tool XML files {{{1
################################################################

sub read_tool_xml_files() {

	my @tool_xml_files = get_tool_xml_files();
	my %tools;

	my $xml_parser = new XML::Simple();
	for my $xml_file (@tool_xml_files) {
		my $xml_file_path = catfile($INPUT_FOLDER, 'tools', $xml_file);
		my $tool = $xml_parser->XMLin($xml_file_path);

		# Version
		die "No tool ID defined inside XML tool file $xml_file_path." if ( ! exists($$tool{id}));
		my $tool_id = $$tool{id};
		$tools{$tool_id} = { id => $tool_id };

		# Name
		$tools{$tool_id}->{name} = $$tool{name} if exists($$tool{name});
			
		# Version
		$tools{$tool_id}->{version} = $$tool{version} if exists($$tool{version});

		# Command
		if (exists($$tool{command})) {
			if (ref($$tool{command})) {
				$tools{$tool_id}->{command}->{interpreter} = $$tool{command}->{interpreter} if exists($$tool{command}->{interpreter});
				$tools{$tool_id}->{command}->{content} = $$tool{command}->{content} if exists($$tool{command}->{content});
			}
			else {
				$tools{$tool_id}->{command}->{content} = $$tool{command};
			}
		}
	}

	return %tools;
}

# Read PhenoMeNal tools2container YAML {{{1
################################################################

sub read_phenomenal_tools2container_yaml(\%) {

	my ($tools) = @_;
	my $yaml_file = catfile($INPUT_FOLDER, 'config', 'phenomenal_tools2container.yaml');
	die "No file \"$yaml_file\"." unless -f $yaml_file;

	# Load YAML file
	my $phn_tools2cont = YAML::Tiny->read($yaml_file)->[0];
	die "Unable to find assignment key in $yaml_file." unless exists($$phn_tools2cont{assignment});
	for my $container (@{$$phn_tools2cont{assignment}}) {

		# Check that required field are defined
		for my $field (qw(docker_image_override docker_tag_override tools_id)) {
			die "No $field field in container." unless exists($$container{$field});
		}

		# Loop on all tools of the container
		for my $tool_id (@{$$container{tools_id}}) {
			tool_error("Unknown tool $tool_id found in container $$container{docker_image_override}, file $yaml_file.") unless exists($$tools{$tool_id});
			$tools->{$tool_id}->{container_image} = $$container{docker_image_override};
			$tools->{$tool_id}->{container_tag} = $$container{docker_tag_override};
		}
	}
}

# Get tools info {{{1
################################################################

sub get_tools_info {

	# Read first info from tool XML files
	my %tools = read_tool_xml_files();

	# Read phenomenal_tools2container.yaml
	read_phenomenal_tools2container_yaml(%tools);

	return %tools;
}

# Check command {{{1
################################################################

sub check_command(\%) {

	my ($tool) = @_;

	tool_warning("Command of tool $$tool{id} uses an interpreter attribute. Use of interpreter attribute inside command tag is discouraged. It tends to make embedded code more complex and renders difficult testing. Please get rid of your explicit call to \"$$tool{command}->{interpreter}\" interpreter, and write a script using a shebang that you will call directly from inside the command tag content, using command line arguments to get different behavious. Testing if such a script is a lot easier, since it can be done outside of Galaxy scope.") if exists $$tool{command}->{interpreter};
	tool_error("Command of tool $$tool{id} uses \$__tool_directory__ variable. Please remove it, as it will prevent the tool to launch in PhenoMeNal Galaxy.") if grep(/\$__tool_directory__/, $$tool{command}->{content});
	tool_warning("Command of tool $$tool{id} uses a complex command (use of && or ; operators). Please simply by calling only one script or program that you can test more accurately outside of Galaxy environment.") if grep(/(&&|;)/, $$tool{command}->{content});
}

# Check container {{{1
################################################################

sub check_container(\%) {

	my ($tool) = @_;

	# Check container tag format
	if ($tool->{container_tag} eq 'latest') {
		tool_error("Container tag of tool $tool->{id} is set to latest.");
	}
	elsif ($tool->{container_tag} =~ m/^(dev_)?v.+_cv.+$/) {

		# Extract tool version
		(my $tool_version = $tool->{container_tag}) =~ s/^(dev_)?v(.+)_cv.+$/$2/;
		tool_error("The tool version ($tool_version) contained inside container tag $tool->{container_tag} of tool $tool->{id} does not match the tool version ($tool->{version}) defined inside the tool XML file.") unless $tool_version eq $tool->{version};
	}
	else {
		tool_error("Container tag $tool->{container_tag} of tool $tool->{id} does not match the format '^(dev_)?v.+_cv.+\$'.");
	}
}

# Main {{{1
################################################################

# Read arguments
read_args();

# Get tool list
my %tools = get_tools_info();

# Loop on all tools
foreach my $tool_id (sort keys %tools) {
	check_command(%{$tools{$tool_id}});
	check_container(%{$tools{$tool_id}});
}

# TODO Check job_conf.xml
# TODO Get containers repos and check tool version in README
# TODO Check that container exists
# TODO Check latest container version on Jenkins.
# TODO Check version of tools in workflows.
# TODO Run it automatically on Travis-CI.
# TODO Pay attention to do not publish names in this file.
# TODO Try to publish report on slack, on some channel (public-admin or release_dalcotidine?).
# TODO Add color option.
# TODO Fail (exit > 0) when at least one error is encountered.
