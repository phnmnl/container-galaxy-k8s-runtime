#!/usr/bin/env perl

use strict;
use warnings "all";
use Deep::Hash::Utils;
use File::Basename;
use File::Spec::Functions 'catfile';
use Getopt::Long;
use XML::Simple;

# Constants {{{1
################################################################

my $SCRIPTNAME = basename($0);
my $SCRIPTPATH = dirname($0);

# Variables {{{1
################################################################

my $INPUT_FOLDER = '.';
my $HELP = 0;

# Print help {{{1
################################################################

sub print_help {
	print "Usage: $SCRIPTNAME [options]

This program will scan the configuration files for tools, and check
that they are correctly defined.

Options:
   -h, --help           Print this help message and exits.
   -i,--input <FOLDER>  Set the input folder to use. Default is '.'.
"
}

# Read args {{{1
################################################################

sub read_args {

	GetOptions('help|h' => \$HELP, 'input|i' => \$INPUT_FOLDER) or print_help();

	print_help() if $HELP;

	if (@ARGV > 0) {
		print "No arguments allowed.\n";
		print_help();
	}
}

# Get tool XML files {{{1
################################################################

sub get_tool_xml_files {

	my $tool_conf_file = catfile($INPUT_FOLDER, 'config', 'tool_conf.xml');
	die "No file \"$tool_conf_file\"." unless -f $tool_conf_file;

	# Read tool_conf.xml and get all XML tool paths.
	my @tool_xml_files;
	my $xml_parser = new XML::Simple;
	my $tools = $xml_parser->XMLin($tool_conf_file);
	while (my @keys = Deep::Hash::Utils::reach($tools)) {
		push(@tool_xml_files, $keys[-1]) if ($keys[-2] eq 'file');
	}

	# Filter out non-PhenoMeNal tools
	@tool_xml_files = grep(/^phenomenal\//, @tool_xml_files);

	return @tool_xml_files;
}

# Get tools info {{{1
################################################################

sub get_tools_info {

	my @tool_xml_files = get_tool_xml_files();
	my %tools;

	my $xml_parser = new XML::Simple();
	for my $xml_file (@tool_xml_files) {
		my $xml_file_path = catfile($INPUT_FOLDER, 'tools', $xml_file);
		my $tool = $xml_parser->XMLin($xml_file_path);

		# Version
		die "No tool ID defined inside XML tool file $xml_file_path." if ( ! exists($$tool{id}));
		my $tool_id = $$tool{id};
		$tools{$tool_id} = { id => $tool_id };

		# Name
		$tools{$tool_id}->{name} = $$tool{name} if exists($$tool{name});
			
		# Version
		$tools{$tool_id}->{version} = $$tool{version} if exists($$tool{version});

		# Command
		if (exists($$tool{command})) {
			if (ref($$tool{command})) {
				$tools{$tool_id}->{command}->{interpreter} = $$tool{command}->{interpreter} if exists($$tool{command}->{interpreter});
				$tools{$tool_id}->{command}->{content} = $$tool{command}->{content} if exists($$tool{command}->{content});
			}
			else {
				$tools{$tool_id}->{command}->{content} = $$tool{command};
			}
		}
	}

	return %tools;
}

# Tool error {{{1
################################################################

sub tool_error($) {
	my ($msg) = @_;

	print("[TOOL ERROR] $msg\n");
}

# Tool warning {{{1
################################################################

sub tool_warning($) {
	my ($msg) = @_;

	print("[TOOL WARNING] $msg\n");
}

# Check command {{{1
################################################################

sub check_command(\%) {
	my ($tool) = @_;

	tool_warning("Command of tool $$tool{id} uses an interpreter attribute. Use of interpreter attribute inside command tag is discouraged. It tends to make embedded code more complex and renders difficult testing. Please get rid of your explicit call to \"$$tool{command}->{interpreter}\" interpreter, and write a script using a shebang that you will call directly from inside the command tag content, using command line arguments to get different behavious. Testing if such a script is a lot easier, since it can be done outside of Galaxy scope.") if exists $$tool{command}->{interpreter};
	tool_error("Command of tool $$tool{id} uses \$__tool_directory__ variable. Please remove it, as it will prevent the tool to launch in PhenoMeNal Galaxy.") if grep(/\$__tool_directory__/, $$tool{command}->{content});
	tool_warning("Command of tool $$tool{id} uses a complex command (use of && or ; operators). Please simply by calling only one script or program that you can test more accurately outside of Galaxy environment.") if grep(/(&&|;)/, $$tool{command}->{content});
}

# Main {{{1
################################################################

# Read arguments
read_args();

# Get tool list
my %tools = get_tools_info();

# Loop on all tools
foreach my $tool_id (sort keys %tools) {
	check_command(%{$tools{$tool_id}});
}

# TODO Check phenomenal_tools2container.yaml
# TODO Check job_conf.xml
# TODO Get containers repos and check tool version in README
# TODO Check that container exists
# TODO Check latest container version on Jenkins.
# TODO Check version of tools in workflows.
# TODO Run it automatically on Travis-CI.
# TODO Pay attention to do not publish names in this file.
# TODO Try to publish report on slack, on some channel (public-admin or release_dalcotidine?).
# TODO Add color option.
